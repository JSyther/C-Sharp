Principles of object-oriented programming

Object-Oriented Programming.

The principles of object- oriented programming (OOP) are a set of concepts that are used to organize and structure code in a way that is easy to understand and maintain.
The main principles of OOP are;

- Encapsulation : hidding the implementation details of an object and exposing only its public interface.
- Inheritance   : allowing classes to inherit properties and methods from a parent class.
- Polymorphism  : allowing objects of different classes to be treated as objects of a common base class.
- Abstraction:  : Abstraction is the process of hiding the complexity of a system and only showing the essential features.
  It can be achieved by using abstract classes and interfaces, which define a contract that the derived classes must implement.

"And there are more than four principles in OOP, however, the Four principles of OOP that are the most fundamental and widely accepted principles.
They are considered the backbone of OOP and are used to create software that is modular, flexible, and easy to maintain."

Encapsulation is the process of hidding the implementation details of an object and exposing only its public interface.
This is done by using access modifiers such as "private", "protected, "public", and "internal".
The "private" members can only be accessed from within the same class, while "public" members can be accessed from anywhere.
"protected members can be accessed from within the same class or any derived class and "internal" members can be accessed from anywhere within the same assembly.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Encapsulation: 
Encapsulation in C# is a feature of object-oriented programmming (OOP) that allows hidding the implementation details of a class and only exposing the necessary
information and functionality through its methods. This helps to protect the internal state of an object and control the way it is accessed and modified.

In C#, encapsulation is achieved by using access modifiers such as "private", "protected" and "public" on fields and properties.
Fields and properties that are marked as "private" are only accessible within the class itself and are not visible to other classes. 

Encapsulation allows for a clean and organized object- oriented design, and it is a powerful tool for code maintainability and security,
as it allows you to control how the internal state of an object can be accessed and modified, and also add validation or other logic as needed.

Encapsulation also allows you to change the implementation of a class without affecting the code that uses it as long as the public interface remains the same.
This is knowns as the principle of information hidding, which is a key concept in object-oriented programming.

Here is an example of Encapsulation in C#:
////////////////////////////////////////////////////////////////////////
////////// class MyClass                                      //////////
////////// {                                                  //////////
//////////     private int myPrivateVar;                      //////////
//////////                                                    //////////
//////////     public void SetMyPrivateVar(int value)         //////////
//////////     {                                              //////////
//////////         myPrivateVar = value;                      //////////
//////////     }                                              //////////
//////////                                                    //////////
//////////     public int GetMyPrivateVar()                   //////////
//////////     {                                              //////////
//////////         return myPrivateVar;                       //////////
//////////     }                                              //////////
////////// }                                                  //////////
////////////////////////////////////////////////////////////////////////
In this example, the class "MyClass" has a private variable "myPrivateVar" and two public methods "SetMyPrivateVar" and "GetMyPrivateVar".
The private variable can only be accessed by the methods within the class, and it can't be accessed from outside of the class.
This ensures that the variable is protected from being modified by external code and can only be modified through the provided methods,
wihch can have additional logic or validation.

Here are couple of examples of encapsulation in C#:
Example 1: Using Properties
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////    class Person                                                                //////////
//////////    {                                                                           //////////
//////////        private string _name;                                                   //////////
//////////        private int _age;                                                       //////////
//////////                                                                                //////////
//////////        public string Name                                                      //////////
//////////        {                                                                       //////////
//////////            get { return _name; }                                               //////////
//////////            set { _name = value; }                                              //////////
//////////        }                                                                       //////////
//////////                                                                                //////////
//////////        public int Age                                                          //////////
//////////        {                                                                       //////////
//////////          get { return _age; }                                                  //////////
//////////          set { _age = value; }                                                 //////////
//////////        }                                                                       //////////
//////////    }                                                                           //////////
//////////                                                                                //////////
//////////    class Program                                                               //////////
//////////    {                                                                           //////////
//////////        static void Main(string[] args)                                         //////////
//////////        {                                                                       //////////
//////////            Person person = new Person();                                       //////////
//////////            person.Name = "Jake Syther";                                        //////////
//////////            person.Age = 30;                                                    //////////
//////////            Console.WriteLine($"Name: {person.Name}, Age: {person.Age}");       //////////
//////////        }                                                                       //////////
//////////    }                                                                           //////////
////////////////////////////////////////////////////////////////////////////////////////////////////
In this example, the class "Person" has two private fields, "_name" and "_age", which are directly accessible from outside of the class.
Instead, properties "Name" and "Age" are used to access and set the values of these fields.
By using properties, we can control the way the fields are accessed and modified, and also add validation or other logic as needed.

More detailed explanation of the above code:
 1. The first class "Person" has two private field, "_name" and "_age", which are not directly accessible from outside of the class.
    These fields represent the name and age of a person respectively.
 2. The class defines two public properties, "Name" and "Age", that are used to access and set the values of the private fields "_name" and "_age".
    The properties use the "get" and "set" accessors to control the way the fields are accessed and modified.
 3. The "get" accessor is used to return the value of the field, in this case, the "get" accessor for "Name" property returns the value of the private field 
    "_name" and the "get" accessor for "Age" property returns the value of the private field "_Age".
 4. The "set" accessor is used to assign a new value to the field, in this case, the "set accessor for "Name" property assigns a new value to the private field "_age".
 5. The next class "Program" has the "Main" method, the entry point of the program. Inside the Main method,
    a new instance of the "Person" class is created and assigned to the variable "person".
 6. The "Name" property of the "person" object is set to "Jake Syther" and the "Age" property is set to 30.
 7. The "Console.WriteLine" method is sused to write the string "Name: Jake Syther, Age: 30" to the console.
    This string is formatted using the "Name" and "Age" properties of the "person" object.
    
    
Example 2: Using Methods
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////    class BankAccount                                                           //////////
//////////    {                                                                           //////////
//////////        private double _balance;                                                //////////
//////////                                                                                //////////
//////////        public void Deposit(double amount)                                      //////////
//////////        {                                                                       //////////
//////////            _balance += amount;                                                 //////////
//////////        }                                                                       //////////
//////////                                                                                //////////
//////////        public void Withdraw(double amount)                                     //////////
//////////        {                                                                       //////////
//////////            if(_balance >= amount)                                              //////////
//////////            {                                                                   //////////
//////////                _balance -= amount;                                             //////////
//////////            }                                                                   //////////
//////////            else                                                                //////////
//////////            {                                                                   //////////
//////////                Console.WriteLine("Insufficient funds.");                       //////////
//////////            }                                                                   //////////
//////////        }                                                                       //////////
//////////                                                                                //////////
//////////        public double GetBalance()                                              //////////
//////////        {                                                                       //////////
//////////            return _balance;                                                    //////////
//////////        }                                                                       //////////
//////////    }                                                                           //////////
//////////                                                                                //////////
//////////    class Program                                                               //////////
//////////    {                                                                           //////////
//////////        static void Main(string[] args)                                         //////////        
//////////        {                                                                       //////////  
//////////            BankAccount account = new BankAccount();                            //////////
//////////            account.Deposit(100);                                               //////////
//////////            account.Withdraw(50);                                               //////////
//////////            Console.WriteLine($"Balance: {account.GetBalance()}");              //////////
//////////        }                                                                       //////////
//////////    }                                                                           //////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
In this example, the class "BankACcount" has a private field "_balance" that represents the account balance.
The class defines three public methods "Deposit", "Withdraw" and "GetBalance" which are used to access and modify the balance.
By using methods, we can control the way the balance field is accessed and modified, and also add validation or other logic as needed.

More detailed explanation of the above code:
 1. The first class "BankAccount" has a private field "_balance" that represents the account balance. This field is not directly accessible from outside of the class.
 2. The class defines three public methods: "Deposit", "Withdraw", and "GetBalance" which are used to access and modify the balance.
 3. The "Deposit" method takes one argument, an double "amount", and it increases the value of the private field "_balance" by the amount passed in.
 4. The "Withdraw" method takes one argument, and double "amount", and it decreases the value of the private field "_balance" by the amount passed in 
    only if the _balance is greater than or equal to the amount passed in, otherwise it will write a message "Insufficient funds" to the console.
 5. The "GetBalance" method returns the value of the private field "_balance"
 6. The class "Program" has the "MAin" method, the entry point of the program.
    Inside the main method, a new instance of the "BankAccount" class is created and assigned to the variable "account".
 7. The "Deposit" method of the "account" object is called with an argument of 100, which increases the balance of the account by 100.
 8. The "Withdraw" method of the "account" object is called with an argument of 50, which decreases the balance of the account by 50 if the balance is greater than
    or equal to 50, otherwise it will a message "Insufficient funds" to the console.
 9. The "Console.WriteLine" method is used to write the string "Balance : 50 " to the console this string is formatted using the result of calling the "GetBalance"
    method of the "account" object.
    
    
In both examples, the implementation details are hidden from the outside world, and the class only exposes the necessary information and functionality through
its properties or methods. This allows for a more flexible and maintainable design, 
as changes to the implementation can be made without affecting code that uses the class.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Inheritance:
Inheritance in C# is a feature of object-oriented programming (OOP) that allows a class to inherit properties and methods from a parent class.
This allows for code reuse and helps to organize the codabase by creating a hierarchy of classes.
	
A class that inherits from a parent class is called a derived class or a child class. The parent class is also known as the base class or the parent class.
	
A derived class can inherit all the members (fields, properties, and methods) of the base class, but it can also add or override members to change or
extend the behavior of the base class. This is done by using the ":" symbol to inherit from the base class.
	
Inheritance allows for a clean and organized object-oriented design, and it is a powerful tool for code reuse, which helps to reduce the amount of code needed to
implement a program.
	
In C#, a class can inherit from only one base class but can implement multiple interfaces, which allows for a more flexible design.


Here is an example of inheritance in C#:
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
////////// class Parent                                                             //////////
//////////  {                                                                       //////////
//////////      public int x;                                                       //////////
//////////      public int y;                                                       //////////
//////////                                                                          //////////
//////////      public void Print()                                                 //////////
//////////      {                                                                   //////////
//////////          Console.WriteLine("x: " + x + ", y " + y);                      //////////
//////////      }                                                                   //////////
//////////  }                                                                       //////////
//////////                                                                          //////////
//////////  class Child : Parent                                                    //////////
//////////  {                                                                       //////////
//////////      public int z;                                                       //////////
//////////      public void Print()                                                 //////////
//////////      {                                                                   //////////
//////////          Console.WriteLine("x: " + x + ", y: " + y + ", z: " + z);       //////////
//////////      }                                                                   //////////
//////////  }                                                                       //////////
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
In this example, the class "Child" inherits from the class "Parent". It inherits the properties "x" and "y" and the method "Print" from the parent class
 and also adds a new property "z" and overrides the "Print" method.

The Child class can access the properties and methods of the parent class as if they were its own, and it can also add new functionality or
override existing functionality.

Here are a couple of examples of inheriance in C#:

Example 1: Simple Inheritance:
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////	class Shape									//////////
//////////	{										//////////
//////////	    public double Width { get; set; }						//////////
//////////	    public double Height { get; set; }						//////////
//////////											//////////
//////////	    public double GetArea()							//////////
//////////	    {										//////////
//////////	        return Width * Height;							//////////
//////////	    }										//////////
//////////	}										//////////
//////////											//////////
//////////											//////////
//////////	class Rectangle : Shape								//////////
//////////	{										//////////
//////////	    public double GetPerimeter()						//////////
//////////	    {										//////////
//////////	        return 2 * (Width + Height);						//////////
//////////	    }										//////////
//////////	}										//////////
//////////											//////////
//////////	class Program									//////////
//////////	{										//////////
//////////	    static void Main(string[] args)						//////////
//////////	    {										//////////
//////////	        Rectangle rectangle = new Rectangle() { Width = 10, Height = 5 };	//////////
//////////	        Console.WriteLine($"Area: {rectangle.GetArea()}");			//////////
//////////	        Console.WriteLine($"Perimeter: {rectangle.GetPerimeter()}");		//////////
//////////	    }										//////////
//////////	}										//////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

In this example, the class "Shape" is defined with properties "Width" and "Height" and a method "GetArea" which is used to calculate the area of the shape.

The class "Rectangle" is derived from "Shape" by using the ":" symbol and it inherits the properties and method of "Shape" class. Additionally, it has its own 
method "GetPerimeter" which is used to calculate the perimeter of the rectangle.

In the main methods of the program, an instance of "Rectangle" class is created and its properties are set, then the "GetArea" and "GetPerimeter methods are called 
and the result is printed on the console.
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
//////////   Console result	        //////////////
//////////////////////////////////////////////////////
//////////   Area: 50			//////////////
//////////   Perimeter: 30		//////////////
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

Example 2: Inheriting with polymorphism
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////	abstract class Shape								//////////
//////////	{										//////////	
//////////	    public double Width { get; set; }						//////////			
//////////	    public double Height { get; set; }						//////////	
//////////	    public abstract double GetArea();						//////////
//////////	}										//////////
//////////											//////////
//////////	class Rectangle : Shape								//////////
//////////	{										//////////
//////////	    public override double GetArea()						//////////
//////////	    {										//////////
//////////	        return Width * Height;							//////////
//////////	    }										//////////
//////////	}										//////////
//////////											//////////
//////////	class Circle : Shape								//////////
//////////	{										//////////
//////////	    public override double GetArea()						//////////	
//////////	    {										//////////
//////////	        return Math.PI * Math.Pow((Width / 2 ), 2);				//////////
//////////	    }										//////////
//////////	}										//////////
//////////											//////////
//////////	class Program									//////////
//////////	{										//////////
//////////	    static void Main(string[] args)						//////////
//////////	    {										//////////
//////////	        Shape rect = new Rectangle() { Width = 10, Height = 5 };		//////////
//////////	        Shape circle = new Circle() { Width = 10 };				//////////
//////////	        Console.WriteLine($"Area of Rectangle: {rect.GetArea()}");		//////////
//////////	        Console.WriteLine($"Area of Circle: {circle.GetArea()}");		//////////
//////////	    }										//////////	
//////////	}										//////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
In this example, the class "Shape" is defined as an abstract class with properties "Width" and "Height" and an absract method "GetArea". The abstract class and 
method area defined with the keyword "abstract", which means that the class cannot be instantiated and the method has no implementation.

The class "Rectangle" and "Circle" are derived from "Shape" and they both inherit the properties "Width" and "Height" and they both override the abstract method
"GetArea" in order to provide their own implementation of the method. The override keyword is used to indicate that the method is intended to override an abstract or
virtual method in the base class.

In the main method of the program, an instance of "Rectangle" and "Circle" class is created and their properties are set, then the "GetArea" method is called on
each instance and the result is printed on the console.

This example demonstrate the concept of polymorphism, which is the ability of a derived class to override the behaviour of a base class and provide its own 
implementation of the method. It allows the program to treat the objects of the derived class as objects of the base class and call the methods with the same
signature on them.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Polymorphism:

Polymorphism is one of the four fundemental principle of object-oriented programming(OOP), which allows a derived class to provide a different implementation of
a method that is already provided by its base class.

Here are a couple of example of polymorphism in C#.

Example 1: Method Overriding
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////	class Shape							//////////
//////////	{								//////////
//////////	    public virtual void Draw()					//////////
//////////	    {								//////////
//////////	        Console.WriteLine("Drawing a shape.");			//////////
//////////	    }								//////////
//////////	}								//////////
//////////									//////////
//////////	class Rectangle : Shape						//////////
//////////	{								//////////
//////////	    public override void Draw()					//////////
//////////	    {								//////////
//////////	        base.Draw();						//////////
//////////	        Console.WriteLine("Drawing a rectangle.");		//////////
//////////	    }								//////////
//////////	}								//////////
//////////									//////////
//////////	class Circle : Shape						//////////
//////////	{								//////////
//////////	    public override void Draw()					//////////
//////////	    {								//////////
//////////	        base.Draw();						//////////
//////////	        Console.WriteLine("Drawing a circle");			//////////
//////////	    }								//////////
//////////	}								//////////
//////////									//////////
//////////	class Program							//////////
//////////	{								//////////
//////////	    static void Main(string[] args)				//////////
//////////	    {								//////////
//////////	        Shape rect = new Rectangle();				//////////
//////////	        Shape circle = new Circle();				//////////
//////////	        rect.Draw();						//////////
//////////	        circle.Draw();						//////////
//////////	    }								//////////
//////////	}								//////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
In this example, the class "Shape" has a virtual method "Draw" with a default implementation that writes a message to the console. The class "Rectangle" and "Circle"
are derived from "Shape" and they both override the "Draw" method in order to provide their own implementation of the method. The "override" keyword is used to
indicate that the method is intended to override a virtual method in the base class.

In the main method of the program, an instance of "Rectangle" and "Circle" class are created and assigned to variable of type "Shape". The "Draw" method is then called 
on each of the objects, which will invoke the overriden implementation of the method in the derived classes.

This is an example of polymorphism, because the same method "Draw" is called on objects of different classes, but it produces different results depending on the class
of the object. The program can treat the objects of the derived class as objects of the base class and call the methods with the same signature on them.
//////////////////////////////////////////////////
//////////	Console Result		//////////
//////////////////////////////////////////////////
//////////	Drawing a rectangle.	//////////
//////////	Drawing a circle	//////////
//////////////////////////////////////////////////

Example 2: Using interface.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////	interface IDrawable											//////////
//////////	{													//////////
//////////	    void Draw();											//////////
//////////	}													//////////
//////////														//////////
//////////	class Shape : IDrawable											//////////
//////////	{													//////////
//////////	    public void Draw()											//////////
//////////	    {													//////////
//////////	        Console.WriteLine("Drawing a shape.");								//////////
//////////	    }													//////////
//////////	}													//////////
//////////														//////////
//////////	class Rectangle : IDrawable										//////////
//////////	{													//////////
//////////	    public void Draw()											//////////
//////////	    {													//////////
//////////	        Console.WriteLine("Drawing a rectangle.");							//////////
//////////	    }													//////////
//////////	}													//////////
//////////														//////////
//////////	class Circle : IDrawable										//////////
//////////	{													//////////
//////////	    public void Draw()											//////////
//////////	    {													//////////
//////////	        Console.WriteLine("Drawing a circle");								//////////
//////////	    }													//////////
//////////	}													//////////
//////////														//////////
//////////	class Program												//////////
//////////	{													//////////
//////////	    static void Main(string[] args)									//////////
//////////	    {													//////////
//////////	        IDrawable[] drawables = new IDrawable[] { new Shape(), new Rectangle(), new Circle() };		//////////
//////////	        foreach (var drawable in drawables)								//////////
//////////	        {												//////////
//////////	            drawable.Draw();										//////////
//////////	        }												//////////
//////////	    }													//////////
//////////	}													//////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
In this example, the interface "IDrawable" is defined with a single method "Draw" with no implementation. The classes "Shape", "Rectangle" and "Circle" all
implement the "IDrawable" interface by providing their own implementation of the "Draw" method.

In the main method of the program, an array of "IDrawable" objects is created and it includes an instance of "Shape", "Rectangle" and "Circle" class. The
"Draw" method is then called on each object in the array using a foreach loop.

This example of polymorphism have same method "Draw" is called objects of different classes, but it produces different results depending on the class of the object.
The program can treat the objects of the different classes as objects of the interface "Idrawable" and call the methods with the same signature on them.
In both examples, polymorphism allows the program to treat objects of different types in a similar way and it makes the code more flixble and
easier to maintain by reducing the need for explicit type checking and casting.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Abstraction :

Abstraction is one of the fundamental principles of object-oriented programming(OOP) that allows hiding the complexity of a system and only showing the essential
features. It can be achieved by using abstract classes and interfaces, which define a contract that the derived classes must implement.
	
Abstraction allows for a clean and organized object-orinted design, and it is a powerful tool for code maintainability and scalability,
as it allows you to focus on the esential features of a system and separate the implementation details from the interface.
	
Here are a couple of examples of Abstraction in C#:

Example 1: Abstract Class
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
abstract class Shape
{
    public abstract double GetArea();
}

class Rectangle : Shape
{
    private double width;
    private double height;

    public Rectangle(double width, double height)
    {
        this.width = width;
        this.height = height;
    }

    public override double GetArea()
    {
        return width * height;
    }
}

class Circle : Shape
{
    private double radius;

    public Circle(double radius)
    {
        this.radius = radius;
    }

    public override double GetArea()
    {
        return Math.PI * radius * radius;
    }
}

Rectangle rect = new Rectangle(5, 10);
double area = rect.GetArea();
Console.WriteLine("Area of rectangle: " + area);

Circle circle = new Circle(5);
area = circle.GetArea();
Console.WriteLine("Area of Circle: " + area);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

In this example, the class "Shape" is defined as an abstract class with a single abstract method "GetArea",
which has no implementation. The abstract class and method are defined with the keyword "abstract", which means that the class cannot be instantiated.

The class "Rectangle" and "Circle" are derived from "Shape" and they both implement the abstract method
"GetArea" in order to provide their own implementation of the method. The override keyword is used to indicate that the method is intended to override
an abstract method in the base class.

In this example, "Shape" class is an abstract class, it can't be instantiated, you can only create object of its child classes "Rectangle" and "Circle"
and you can use the method GetArea() on each of them and you will get the correct result based on the implementation of this method in each class.


Detailed Explanition:
1. The abstract class "Shape" is defined with an abstract method "GetArea" which has no implementation. The keyword "abstract" is used to indicate
   that the class and method are intended to be abstract.
2. The class "Rectangle" is derived from "Shape" and it has two private fields "width" and "height" which are used to store the width and height of the rectangle.
3. The class "Rectangle" has a constructor which takes two parameters "width" and "height", it assigns these values to the private fields "width" and "height"
   respectively.
4. The class "Rectangle" also implements the abstract method "GetArea" by providing its own implementation which calculates the area of the rectangle
   by multiplying the width and height of the rectangle and returns the result.
5. The class "Circle" is also derived from "Shape" and it has a private field "radius" which is used to store the radius of the circle.
6. The class "Circle" has a constructor which takes one parameter "radius", it assigns this value to the private field "radius".
7. The class "Circle" also implements the abstract method "GetArea" by providing its own implementation which calculates the area of the circle by multiplying
   the radius of the circle by pi and square of the radius and returns the result.
8. In main method, you can create objects for both classes and use GetArea() method on each one of them, for example:

The output of this example will be:
////////////////////////////////////////
Area of rectangle: 50
Area of Circle: 78.53981633974483
////////////////////////////////////////

The first output line shows the calculated area of the rectangle object created with width of 5 and height of 10, which is 50.
The second output line shows the calculated area of the Circle object created with radius of 5, which is 78.53981633974483 using Math.PI.

Please note that the value of Math.PI is the approximation of pi, it's the constant value of pi in C#.

Example 2: Interface
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
abstract class Shape
{
    public abstract double GetArea();
}

class Rectangle : Shape
{
    private double width;
    private double height;

    public Rectangle(double width, double height)
    {
        this.width = width;
        this.height = height;
    }

    public override double GetArea()
    {
        return width * height;
    }
}

class Circle : Shape
{
    private double radius;

    public Circle(double radius)
    {
        this.radius = radius;
    }

    public override double GetArea()
    {
        return Math.PI * radius * radius;
    }
}
Rectangle rect = new Rectangle(5, 10);
double area = rect.GetArea();
Console.WriteLine("Area of rectangle: " + area);

Circle circle = new Circle(5);
area = circle.GetArea();
Console.WriteLine("Area of Circle: " + area);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
In this example is an implementation of abstraction using an interface. The interface "Idrawable" defines a single method "Draw" which has no implementation. The classes "Shape", "Rectangle" and "Circle" all implement the "IDrawable" interface by providing their own implementation of the "Draw" method.
	
Here is a step by step explanation of the example:

1. The interface "IDrawable" is defined with a single method "Draw" with no implementation. The keyword "interface" is used to indicate that the class is an interface.

2. The class "Shape" is defined and it implements the "IDrawable" interface. It provides its own implementation of the "Draw" method which outputs
   the string "Drawing a shape."

3. The class "Rectangle" is defined and it also implements the "IDrawable" interface. It provides its own implementation of the "Draw" method which outputs
   the string "Drawing a rectangle."

4. The class "Circle" is defined and it also implements the "IDrawable" interface. It provides its own implementation of the "Draw" method which outputs the string
   "Drawing a circle."
   
5. In main method, you can create objects for these classes and use Draw() method on each one of them, for example:

This will output:
//////////////////////////////////////
Area of rectangle: 50
Area of Circle: 78.53981633974483
//////////////////////////////////////


This example is similar to the previous one, but instead of using an abstract class, an interface is used to define the contract that the derived classes must implement. The interface defines a single method "Draw" that must be implemented by any class that implements the interface.

In the main method of the program, an array of "IDrawable" objects is created and it includes an instance of "Shape", "Rectangle" and "Circle" class. 
The "Draw" method is then called on each object in the array using a foreach loop.

This example shows how interfaces can be used to define a contract that multiple classes can implement, and it allows the program to treat the objects
of the different classes in a similar way by calling the same method on each of them.

In summary, Abstraction is a key concept in OOP, it allows you to focus on the essential features of a system and separate the implementation details
from the interface. It can be achieved by using abstract classes and interfaces, which define a contract that the derived classes must implement.
This allows for a clean and organized object-oriented design, and it makes the code more maintainable, scalable, and easy to understand.


In conclusion, the principle of object-oriented programming (OOP) are a set of concept that are used to organize and structure code in a way that is easy to understand
and maintain. The main principle of OOP are encapsulation, inheritance, and polymorphism. Encapsulation allows you to hide the implementation details of an object
and expose only its public interface. Inheritance allows classes to inherit properties and methods from a parent class.
Polymorphism allows objects of different classes to be treated as objects of a common base class.
Understanding and using these principles correctly can make your code more organized, maintainable, and reusable.



