Generics: 

Generics in C# allow you to write code that can work with multiple types, rather than being tied to a specific type.
This can make your code more flexible and reusable.

Here's an example of a simple generic class:

------------------------------------------------------------------------------------------------------------------------------------------------------------------
public class MyGenericClass<T>
{
  private T_value;
  
  public MyGenericClass(T value)
  {
    _value = value;
  }
  
  public T GetValue()
  {
    return _value;
  }
  
  public void SetValue(T value)
  {
    _value = value;
  }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------

In this example, the class "MyGenericClass" has a generic type parameter "T", which is used to define the type of the private field "_value".
The class has a constructor that takes an argument of type "T", and two methods "GetValue" and "SetValue" that also use "T".

You can create an instance of this class for any type you want.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

MyGenericClass<int> my IntObject = new MyGenericClass<int>(5);          // We set the "IntObject" generic type variable to an integer and assigned it to a value of 5.
int myInt = myIntObject.GetValue(); // myInt will be 5                  // GetValue() method is called and the value of the variable "myInt" is equal to 5.

MyGenericClass<string> myStringOBject = new MyGenericClass<string>("Welcome to the reality!");
// We set the "myStringOBject" generic type variable to an string and assigned it to a value of "Welcome to the Reality!".
string myString = myStringObject.GetValue(); // "myString" pure string variable is now equal to with called method myStringObject's value.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

You can also use generic methods, which are methods that have a generic type parameter.
For example: 
------------------------------------------------------------------------------------------------------------------------------------------------------------------
public static void Swap<T>(ref T a, ref T b)
{
  T temp = a;
  a = b;
  b = temp;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
This method takes two arguments of the same type, and swaps their values. You can call it with any type:
------------------------------------------------------------------------------------------------------------------------------------------------------------------
int x = 5;
int y = 10;
Swap(ref x, refy); // x is now 10, y is now 5
------------------------------------------------------------------------------------------------------------------------------------------------------------------
You can also use consstraints on the generic type parameter.
For example, you can specify that the type must implement a certain interface or inherit from a certain class:
------------------------------------------------------------------------------------------------------------------------------------------------------------------
public class MyConstrainedGenericClass<T> where T : IMyInterface
{
  // class implementation
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
This limits the types that can be used as the generic type parameter for this class to those that implement the IMyInterface interface.

There are more advanced usage of Generic like IEnumerable, ICollection and IList which are commonly used interfaces that allow you to work with collections of items
in a type-safe way. You can also use the generic List<T> class, which is a built-in collection class that implements these interfaces.

Another example is Generic Constraints:
In some cases, you may want to impose certain constraints on the type parameter of a generic class or method.
For example, you may want to ensure that the type parameter implements a certain interface or is derived from a certain class.
You can do this using generic constraints. For example, here is a simple generic class called "MyCompare" that has a type parameter T,
and it's constrained to be only of type which is class and must implement IComparable interface, this way it can be used for comparison purpose:
------------------------------------------------------------------------------------------------------------------------------------------------------------------
class MyCompare<T> where T: class, IComparable
{
    public bool IsGreater(T a, T b)
    {
        return a.CompareTo(b) > 0;
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
You can create an object of the class and use IsGreater method on it, for example:
------------------------------------------------------------------------------------------------------------------------------------------------------------------
MyCompare<int> compareInt = new MyCompare<int>();
bool isGreater = compareInt.IsGreater(1,2);
Console.WriteLine(isGreater);
//This will output: False
------------------------------------------------------------------------------------------------------------------------------------------------------------------
These are the basic concepts and examples of how to use generics in C#. With Generics, you can make your code more flexible, reusable, and type-safe.
You can also use them to constrain the types of variables that can be used with your classes and methods, which can help you to prevent errors and improve performance.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------



Generic Examples;
------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace ReverseA
{
    class SimpleList<T>
    {
      private List<T> items = new List<T>();

      public void Add(T item)
      {
        items.Add(item);
      }

      public T this[int index]
      {
        get {return items[index];
      }

    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. The class is declared as a generic class, with the type parameter T in angle brackets <T>. This means that the class can work with any type, as long as the type
   is specified when creating an instance of the class.
2. Inside the class, a private field items of type List<T> is declared. This field will be used to store the items of the list. The List<T> class is part of the C#
   standard library and provides a dynamic list of items of a specified type.
3. The Add mnethod is declared, which takes a single parameter of type T. This method simply adds the passed item to the items list by calling the Add method on the
   items list.
4. The this indexer property is declared, which allows items to be accessed by index. The property has a get accessor that returns the item at the specified index
   from the items list.
5. The class does not have a constructor, so the items field is initalized with a new instance of List<T> when the class is instantiated.
6. When you create an instance of the class and specify the type, the class is ready to use. You can add items to the list using the Add method and access them 
   using the indexer property, like this:
   ------------------------------------------------------------------------------------------------------------------------------------------------------------------
   SimpelList<int> intList = new SimpleList<int>();
   intList.Add(1);
   Console.WriteLine(intList[0]); //Output: 1
------------------------------------------------------------------------------------------------------------------------------------------------------------------
7. You can also use other types like custom class.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
class Person
{
  public string Name {get;set;}
  public int Age {get;set;}
}

SimpleList<Person> personList = new SimpleList<Person>();
personList.Add(new Person{Name = "Jake", Age = 30});
Console.WriteLine(personList[0].Name);  //Output: "John"
------------------------------------------------------------------------------------------------------------------------------------------------------------------
In summary, The SimpleList class ia generic class that can be used to store items of any type, as long as the type is specified when creating an instance of the
class. The Add method is used to add items to the list, and the indexer property is used to access the items by index.
